# 从静态到互动：为什么可恢复性是水化的最佳选择

> [原文](https://www.builder.io/blog/from-static-to-interactive-why-resumability-is-the-best-alternative-to-hydration)

![img](img\hydration.png)



没有人想要一个缓慢的、没有反应的网站。当涉及到网站性能优化时，预渲染你的网站是你作为一个网站开发者最强大的工具之一。

几乎所有的前端JavaScript（JS）框架都有办法通过服务器端渲染（SSR）或静态网站生成（SSG）将内容预先渲染为HTML。其结果是，当HTML流向用户的浏览器时，网站几乎立即显示。

然而，有一个问题。HTML是静态的，而网站通常是动态和互动的。框架如何使预渲染的HTML在浏览器上互动？

目前这一代框架通过一个叫做 "水化 "的客户端过程来解决这个问题，这是一个资源密集型的过程，为页面的启动成本增加了大量的开销。

![img](\img\speedvs.png)

这是我有争议的观点：水化是当你把SSR/SSG作为事后的想法加入到前端框架中时发生的事情。

一个为预渲染而设计的框架可以通过在服务器上序列化状态并在客户端恢复状态来避免水化及其性能损失。

在深入研究序列化和可恢复性之前，让我们来谈谈水化所解决的问题。



## 一个框架如何使一个页面具有互动性？

任何前端框架都需要三样东西才能对互动性做出反应：

1. 关联事件处理程序。框架必须有办法将DOM元素与它们相应的事件处理程序联系起来，这些事件处理程序是响应用户输入并实现与你的网站互动的功能。
2. 恢复应用状态。一旦一个用户事件触发了一个事件处理程序，该函数就会更新应用状态。
3. 重新创建组件层次结构。一旦应用状态更新，框架需要重新渲染应用视图以向用户反映状态。框架必须理解状态和组件之间的关系以完成渲染。

让我们深入了解水合作用如何处理这些任务，以及为什么它是一种昂贵的方法。

![img](\img\demo.png)

### 关联事件处理程序

框架通过执行组件模板将事件处理程序与特定的DOM元素联系起来。例如，在React中，一个用JSX编写的按钮组件可能有一个带有事件处理程序的onClick道具。Hydration要求浏览器在关联事件处理程序之前下载并执行所有组件的模板。

不幸的是，JS包的下载大小和代码执行时间与页面的复杂性成正比。一个小的演示页面会下载少量的JS并快速执行，但是当涉及到真实世界的页面时，引导成本就会变得非常昂贵，往往会导致多秒的交互时间（TTI）。

一些框架通过尝试延迟页面的某些部分被渲染来缓解这种性能损失。这种策略对于以内容为中心的页面，如营销页面，效果相当好。然而，对于像网络应用这样组件以复杂方式共享状态的网站，框架仍然需要下载DOM树中的每个组件并执行其模板。



### 恢复应用程序的状态

事件处理程序需要一个应用程序的状态来更新，这个状态在预渲染时存在于服务器上。框架必须在客户端重构这个状态，以便DOM能够正确更新。

Hydration的基本方法是在浏览器中再次执行在服务器上生成应用状态的相同代码，这增加了执行时间并延迟了互动性。

这就是为什么许多元框架将服务器上的应用状态序列化，并将其包含在HTML中，这样就可以使用JSON.parse()恢复状态。反序列化比在浏览器上执行应用程序代码来重建状态要快得多，而且它对简单和复杂的页面都很有效。

然而，即使应用程序的状态被序列化，hydration仍然通过缓慢地执行代码来重建内部框架状态。

### 重新创建组件层次结构

![img](https://cdn.builder.io/api/v1/image/assets%2FYJIGb4i01jvw0SRdL5Bt%2F65caa495f5074d14a8eb9866b3c5ce57?width=800)

对于最后一块，框架需要重新创建组件的层次结构，这是框架内部状态的一部分。它记录了当你的应用程序状态发生变化时，哪些组件需要被重新渲染。

与它将事件处理程序与DOM元素联系起来的方式类似，Hydration必须下载一个页面的所有组件并执行它们的模板来重建组件层次，这就增加了更多的开销。

## 补水的替代品

前端框架进行水合，以恢复事件处理程序、应用程序状态和组件层次结构，以使页面互动。

每个步骤都需要下载和执行代码，这很昂贵。尤其是在使用水合时，代码执行时间与你的页面的复杂性成正比。我们可以用一个方程式来粗略地模拟这个限制。

![Time to interactive = hydration execution cost * page complexity + payload size](https://cdn.builder.io/api/v1/image/assets%2FYJIGb4i01jvw0SRdL5Bt%2F8c7240165b4c41d290b82209df7eb76e?width=800)

无论你的有效载荷有多小，水合总是一个瓶颈。

解决这个问题的一个办法是不需要执行任何代码来恢复页面的交互性，我们可以通过序列化来做到这一点。如上所述，许多元框架已经将应用状态序列化了。为什么不把事件处理程序关联和组件层次结构也序列化呢？

因为这实在是太难了!

函数闭包、承诺和资源引用，以及其他结构，都很难序列化。所以一个框架的设计需要考虑到可序列化和可恢复性。这些功能并不容易被添加到现有的框架中，而不需要大规模的破坏性改变。

将页面状态序列化为HTML的最大好处是，使页面互动不需要下载或执行任何模板代码。框架只是简单地恢复了页面。

![img](https://cdn.builder.io/api/v1/image/assets%2FYJIGb4i01jvw0SRdL5Bt%2F73768ea2bcb54fc7826d15de3d3f3019?width=800)

底线是什么？可恢复的框架会将执行成本降低到零，并且无论页面的复杂程度如何，都会产生一个恒定的开销。







